<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>shiro权限管理框架</title>
      <link href="/2019/09/28/shiro%E4%BB%8B%E7%BB%8D.1/"/>
      <url>/2019/09/28/shiro%E4%BB%8B%E7%BB%8D.1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-shiro-介绍"><a href="#1-shiro-介绍" class="headerlink" title="1 shiro 介绍"></a>1 shiro 介绍</h2><h3 id="1-1-什么是shiro"><a href="#1-1-什么是shiro" class="headerlink" title="1.1 什么是shiro"></a>1.1 什么是shiro</h3><blockquote><p>ApacheShiro 是 Java 的一个安全框架。Shiro 可以非常容易的开发出足够好的应用，其不仅可以用在 JavaSE 环境，也可以用在 JavaEE 环境。Shiro 可以帮助我们完成：认证、 授权、加密、会话管理、与 Web 集成、缓存等。</p></blockquote><h3 id="1-2-为什么要学shiro"><a href="#1-2-为什么要学shiro" class="headerlink" title="1.2 为什么要学shiro"></a>1.2 为什么要学shiro</h3><blockquote><p>既然 shiro 将安全认证相关的功能抽取出来组成一个框架，使用 shiro 就可以非常快速的 完成认证、授权等功能的开发，降低系统成本。<br>shiro 使用广泛，shiro 可以运行在 web 应用，非 web 应用，集群分布式应用中越来越多 的用户开始使用 shiro。<br>java领域中springsecurity(原名Acegi)也是一个开源的权限管理框架，但是springsecurity 依赖 spring 运行，而 shiro 就相对独立，最主要是因为 shiro 使用简单、灵活，所以现在越来 越多的用户选择 shiro。</p></blockquote><h3 id="1-3-基本功能"><a href="#1-3-基本功能" class="headerlink" title="1.3 基本功能"></a>1.3 基本功能</h3><blockquote><p><img src="/images/shiro%E4%BB%8B%E7%BB%8D/20190928130257.jpg" alt></p><blockquote><h3 id="1-3-1-Authentication"><a href="#1-3-1-Authentication" class="headerlink" title="1.3.1 Authentication"></a>1.3.1 Authentication</h3><p>身份认证/登录，验证用户是不是拥有相应的身份；</p><h3 id="1-3-2-Authorization"><a href="#1-3-2-Authorization" class="headerlink" title="1.3.2 Authorization"></a>1.3.2 Authorization</h3><p>授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用 户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用 户对某个资源是否具有某个权限；</p><h3 id="1-3-3-SessionManager"><a href="#1-3-3-SessionManager" class="headerlink" title="1.3.3 SessionManager"></a>1.3.3 SessionManager</h3><p>会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信 息都在会话中；会话可以是普通 JavaSE 环境的，也可以是如 Web 环境的； Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储； WebSupport：Web 支持，可以非常容易的集成到 Web 环境； Caching：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以 提高效率； Concurrency：shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能 把权限自动传播过去； Testing：提供测试支持； RunAs：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问； RememberMe：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录 了。 Shiro 不会去维护用户、维护权限；这些需要我们自己去设计/提供；然后通过 相应的接口注入给 Shiro 即可。</p></blockquote></blockquote><h3 id="1-4-Shiro架构"><a href="#1-4-Shiro架构" class="headerlink" title="1.4 Shiro架构"></a>1.4 Shiro架构</h3><blockquote><p><img src="/images/shiro%E4%BB%8B%E7%BB%8D/20190928132015.jpg" alt></p><blockquote><h3 id="1-4-1-Subject"><a href="#1-4-1-Subject" class="headerlink" title="1.4.1 Subject"></a>1.4.1 Subject</h3><p>Subject 即主体，外部应用与 subject 进行交互，subject 记录了当前操作用户，将用户的 概念理解为当前操作的主体，可能是一个通过浏览器请求的用户，也可能是一个运行的程序。 Subject 在 shiro 中是一个接口，接口中定义了很多认证授相关的方法，外部程序通过 subject 进行认证授，而 subject 是通过 SecurityManager 安全管理器进行认证授权</p><h3 id="1-4-2-SecurityManager"><a href="#1-4-2-SecurityManager" class="headerlink" title="1.4.2 SecurityManager"></a>1.4.2 SecurityManager</h3><p>SecurityManager 即安全管理器，对全部的 subject 进行安全管理，它是 shiro 的核心， 负责对所有的 subject 进行安全管理。通过 SecurityManager 可以完成 subject 的认证、授权 等，实质上 SecurityManager 是通过 Authenticator 进行认证，通过 Authorizer 进行授权，通 过 SessionManager 进行会话管理等。 SecurityManager 是一个接口，继承了 Authenticator,Authorizer,SessionManager 这三个接 口。</p><h3 id="1-4-3-Authenticator"><a href="#1-4-3-Authenticator" class="headerlink" title="1.4.3 Authenticator"></a>1.4.3 Authenticator</h3><p>Authenticator 即认证器，对用户身份进行认证，Authenticator 是一个接口，shiro 提供 ModularRealmAuthenticator 实现类，通过 ModularRealmAuthenticator 基本上可以满足大多数<br>需求，也可以自定义认证器。</p><h3 id="1-4-4-Authorizer"><a href="#1-4-4-Authorizer" class="headerlink" title="1.4.4 Authorizer"></a>1.4.4 Authorizer</h3><p>Authorizer 即授权器，用户通过认证器认证通过，在访问功能时需要通过授权器判断用 户是否有此功能的操作权限。</p><h3 id="1-4-5-realm"><a href="#1-4-5-realm" class="headerlink" title="1.4.5 realm"></a>1.4.5 realm</h3><p>Realm 即领域，相当于 datasource 数据源， securityManager 进行安全认证需要通过 Realm 获取用户权限数据，比如：如果用户身份数据在数据库那么 realm 就需要从数据库获取用户 身份信息。<br>注意：不要把 realm 理解成只是从数据源取数据，在 realm 中还有认证授权校验的相关 的代码。</p><h3 id="1-4-6-sessionManager"><a href="#1-4-6-sessionManager" class="headerlink" title="1.4.6 sessionManager"></a>1.4.6 sessionManager</h3><p>sessionManager 即会话管理， shiro 框架定义了一套会话管理，它不依赖 web 容器的 session， 所以 shiro 可以使用在非 web 应用上，也可以将分布式应用的会话集中在一点管理，此特性 可使它实现单点登录。</p><h3 id="1-4-7-SessionDAO"><a href="#1-4-7-SessionDAO" class="headerlink" title="1.4.7 SessionDAO"></a>1.4.7 SessionDAO</h3><p>SessionDAO 即会话 dao，是对 session 会话操作的一套接口，比如要将 session 存储到数据库， 可以通过 jdbc 将会话存储到数据库。</p><h3 id="1-4-8-CacheManager"><a href="#1-4-8-CacheManager" class="headerlink" title="1.4.8 CacheManager"></a>1.4.8 CacheManager</h3><p>CacheManager 即缓存管理，将用户权限数据存储在缓存，这样可以提高性能。</p><h3 id="1-4-9-Cryptography"><a href="#1-4-9-Cryptography" class="headerlink" title="1.4.9 Cryptography"></a>1.4.9 Cryptography</h3><p>Cryptography 即密码管理，shiro 提供了一套加密/解密的组件，方便开发。比如提供常 用的散列、加/解密等功能。</p></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> shiro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shiro认证</title>
      <link href="/2019/09/28/shiro%E8%AE%A4%E8%AF%81/"/>
      <url>/2019/09/28/shiro%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h1 id="shiro-认证"><a href="#shiro-认证" class="headerlink" title="shiro 认证"></a>shiro 认证</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h2><h3 id="1-1-身份验证"><a href="#1-1-身份验证" class="headerlink" title="1.1 身份验证"></a>1.1 身份验证</h3><blockquote><p>即在应用中谁能证明他就是他本人。一般提供如他们的身份 ID 一些标识信息来 表明他就是他本人，如提供身份证，用户名/密码来证明。 在 shiro 中，用户需要提供 principals （身份）和 credentials（证明）给 shiro，从而应用能 验证用户身份：</p></blockquote><h3 id="1-2-principals"><a href="#1-2-principals" class="headerlink" title="1.2 principals"></a>1.2 principals</h3><blockquote><p>身份，即主体的标识属性，可以是任何东西，如用户名、邮箱等，唯一即可。 一个主体可以有多个 principals，但只有一个 Primaryprincipals，一般是用户名/密码/手机号。</p></blockquote><h3 id="1-3-credentials"><a href="#1-3-credentials" class="headerlink" title="1.3 credentials"></a>1.3 credentials</h3><blockquote><p>证明/凭证，即只有主体知道的安全值，如密码/数字证书等。 最常见的 principals 和 credentials 组合就是用户名/密码了。接下来先进行一个基本的身 份认证。</p></blockquote><h2 id="2-认证流程"><a href="#2-认证流程" class="headerlink" title="2 认证流程"></a>2 认证流程</h2><blockquote><p><img src="/images/shiro%E8%AE%A4%E8%AF%81/20190928133723.jpg" alt></p></blockquote><h2 id="3-入门程序（用户登陆和退出）"><a href="#3-入门程序（用户登陆和退出）" class="headerlink" title="3 入门程序（用户登陆和退出）"></a>3 入门程序（用户登陆和退出）</h2><blockquote><h3 id="3-1-创建-java-工程"><a href="#3-1-创建-java-工程" class="headerlink" title="3.1 创建 java 工程"></a>3.1 创建 java 工程</h3><h3 id="3-2-加入相关-jar-包"><a href="#3-2-加入相关-jar-包" class="headerlink" title="3.2 加入相关 jar 包"></a>3.2 加入相关 jar 包</h3><blockquote><pre><code>commons-beanutils-1.9.2.jar commons-logging-1.2.jar unit-4.10.jar shiro-all-1.2.3.jar slf4j-api-1.7.7.jar log4j-1.2.17.jar slf4j-log4j12-1.7.5.jar```</code></pre></blockquote><h3 id="3-3-log4j-properties-日志配置文件"><a href="#3-3-log4j-properties-日志配置文件" class="headerlink" title="3.3 log4j.properties 日志配置文件"></a>3.3 log4j.properties 日志配置文件</h3><blockquote><p>log4j.rootLogger=debug, stdout<br>log4j.appender.stdout=org.apache.log4j.ConsoleAppender<br>log4j.appender.stdout.layout=org.apache.log4j.PatternLayout<br>log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m %n</p></blockquote><h3 id="3-4-配置-shiro-环境文件-shiro-ini"><a href="#3-4-配置-shiro-环境文件-shiro-ini" class="headerlink" title="3.4 配置 shiro 环境文件 shiro.ini"></a>3.4 配置 shiro 环境文件 shiro.ini</h3><p>通过 Shiro.ini 配置文件初始化 SecurityManager 环境。 </p><blockquote><p>[users]<br>zhangsan=1111<br>lisi=1111</p></blockquote><h3 id="3-5-代码实现"><a href="#3-5-代码实现" class="headerlink" title="3.5 代码实现"></a>3.5 代码实现</h3><blockquote><pre><code>//用户登录和退出 @Test public void testAuthenticator(){     // 构建 SecurityManager 工厂，IniSecurityManagerFactory 可以 从 ini 文件中初始化 SecurityManager 环境     Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;);     //通过工厂获得 SecurityManager 实例    SecurityManager securityManager = factory.getInstance();     //将 securityManager 设置到运行环境中     SecurityUtils.setSecurityManager(securityManager);     //获取 subject 实例     Subject subject = SecurityUtils.getSubject();     //创建用户名,密码身份验证     Token UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhangsan&quot;, &quot;1111&quot;);     try {         //登录，即身份验证         subject.login(token);         } catch (AuthenticationException e) {              e.printStackTrace();              //身份认证失败         }     //断言用户已经登录     Assert.assertEquals(true, subject.isAuthenticated());     //退出     subject.logout(); }</code></pre></blockquote><h3 id="1-4-6-sessionManager"><a href="#1-4-6-sessionManager" class="headerlink" title="1.4.6 sessionManager"></a>1.4.6 sessionManager</h3></blockquote><h2 id="4-自定义-Realm"><a href="#4-自定义-Realm" class="headerlink" title="4 自定义 Realm"></a>4 自定义 Realm</h2><p>Shiro 默认使用自带的 IniRealm，IniRealm 从 ini 配置文件中读取用户的信息，大部分情 况下需要从系统的数据库中读取用户信息，所以需要自定义 realm。</p><blockquote><h3 id="4-1Realm-接口"><a href="#4-1Realm-接口" class="headerlink" title="4.1Realm 接口"></a>4.1Realm 接口</h3><blockquote><p><img src="/images/shiro%E8%AE%A4%E8%AF%81/20190928135215.jpg" alt><br>最基础的是 Realm 接口，CachingRealm 负责缓存处理，AuthenticationRealm 负责认证， AuthorizingRealm 负责授权，通常自定义的 realm 继承 AuthorizingRealm。</p></blockquote><h3 id="4-2-自定义-Realm-实现"><a href="#4-2-自定义-Realm-实现" class="headerlink" title="4.2 自定义 Realm 实现"></a>4.2 自定义 Realm 实现</h3><blockquote><pre><code> /**   *自定义  *Realm 实现   *@author 邹波   *@version 1.0   *@date 2016-1-21   */  public class UserRealm extends AuthorizingRealm {      @Override      public String getName() {          return &quot;UserRealm&quot;;     }     //用于认证     @Override     protected AuthenticationInfo doGetAuthenticationInfo( AuthenticationToken token) throws AuthenticationException {         //从 token 中获取身份信息         String username = (String)token.getPrincipal();         //根据用户名到数据库中取出用户信息 如果查询不到 返回 null         String password = &quot;1111&quot;;        //假如从数据库中获取密码为 1111         //返回认证信息         SimpleAuthenticationInfo simpleAuthenticationInfo = new SimpleAuthenticationInfo(username, password, this.getName());         return simpleAuthenticationInfo;     }     //用于授权    @Override     protected AuthorizationInfo doGetAuthorizationInfo( PrincipalCollection principals) {         return null;     } }</code></pre></blockquote><h3 id="4-3-配置-Realm"><a href="#4-3-配置-Realm" class="headerlink" title="4.3 配置 Realm"></a>4.3 配置 Realm</h3><p>需要在 shiro.ini 配置 realm 注入到 securityManager 中。 </p><blockquote><pre><code>[main] #自定义 realmuserRealm=cn.siggy.realm.UserRealm #将 realm 设置到 securityManager securityManager.realms=$userRealm</code></pre></blockquote><h3 id="4-4-测试"><a href="#4-4-测试" class="headerlink" title="4.4 测试"></a>4.4 测试</h3><p>同上一样</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> shiro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客开发-后台</title>
      <link href="/2019/09/22/blogBackStage/"/>
      <url>/2019/09/22/blogBackStage/</url>
      
        <content type="html"><![CDATA[<h2 id="一、我的第一个博客"><a href="#一、我的第一个博客" class="headerlink" title="一、我的第一个博客"></a>一、我的第一个博客</h2><h3 id="预览图"><a href="#预览图" class="headerlink" title="预览图"></a>预览图</h3><p><img src="/images/backStage/20190923223733.jpg" alt="后台主页"><br><img src="/images/backStage/20190923223807.jpg" alt="写博客"><br><img src="/images/backStage/20190923223826.jpg" alt="博客信息管理"><br><img src="/images/backStage/20190923223845.jpg" alt="博客类别管理"><br><img src="/images/backStage/20190923224255.jpg" alt="评论审核"><br><img src="/images/backStage/20190923224308.jpg" alt="上传图片"><br><img src="/images/backStage/20190923224326.jpg" alt="图片信息管理"><br><img src="/images/backStage/20190923224346.jpg" alt="相册信息管理"></p>]]></content>
      
      
      <categories>
          
          <category> 个人博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客开发-前台</title>
      <link href="/2019/09/22/blogFrontDesk/"/>
      <url>/2019/09/22/blogFrontDesk/</url>
      
        <content type="html"><![CDATA[<h2 id="一、我的第一个博客"><a href="#一、我的第一个博客" class="headerlink" title="一、我的第一个博客"></a>一、我的第一个博客</h2><h3 id="预览图"><a href="#预览图" class="headerlink" title="预览图"></a>预览图</h3><p><img src="/images/frontDesk/20190923223254.jpg" alt="主页"><br><img src="/images/frontDesk/20190923223401.jpg" alt="文章页"><br><img src="/images/frontDesk/20190923223500.jpg" alt="文章详情页"><br><img src="/images/frontDesk/20190923223520.jpg" alt="相册页"><br><img src="/images/frontDesk/20190923223552.jpg" alt="相册详情页"><br><img src="/images/frontDesk/20190923223615.jpg" alt="留言页"><br><img src="/images/frontDesk/20190923223633.jpg" alt="关于我"></p>]]></content>
      
      
      <categories>
          
          <category> 个人博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
